‚úÖ Step 1 ‚Äî Confirm who‚Äôs re-enabling
Search your initVehiclePopupForm() function for something like:
$(".k-widget").each(... widget.enable(true) ...)

or a call that rebuilds widgets (e.g., reapplying .kendoComboBox() or .kendoTextBox()).
That will explain why your readonly state doesn‚Äôt persist.
You can test this by commenting out window.initVehiclePopupForm() temporarily ‚Äî you‚Äôll see your read-only state stick.

‚úÖ Step 2 ‚Äî Make setPopupReadonly() run after the popup form initialization
Since initVehiclePopupForm runs after you load the HTML, we‚Äôll chain setPopupReadonly() after it completes.
If initVehiclePopupForm() doesn‚Äôt have a callback, wrap it in a short timeout (it‚Äôs safe since widget setup is synchronous):
loadVehicleForm(window.currentVehicleId, function () {
    // wait for initVehiclePopupForm to finish its setup
    setTimeout(function () {
        console.warn('Applying readonly after initVehiclePopupForm');
        setPopupReadonly([
            "VehicleListId", "VehSeriesCode", "ProjDesc", "Make", "VehModel", "Year",
            "Engine", "Transmission", "Differential", "Sopnumber",
            "ModifiedLastBy", "ModifiedLastDate"
        ]);
        setPopupEditable(["NumOfVehicles"]);
    }, 200);
});

‚úÖ That ensures your readonly logic runs last, overriding whatever init logic happens earlier.

‚úÖ Step 3 ‚Äî Harden setPopupReadonly() against ComboBox quirks
Kendo ComboBoxes and DropDownLists sometimes need both widget.enable(false) and manual DOM disabling to fully prevent focus.
Update your helper to handle that properly:
window.setPopupReadonly = function (ids) {
    ids.forEach(function (id) {
        var widget = getKendoWidget(id);
        if (widget && typeof widget.enable === "function") {
            widget.enable(false);

            // extra lock for ComboBox/DropDownList inputs
            var wrapper = widget.wrapper || $("#" + id).closest(".k-widget");
            wrapper.addClass("k-state-disabled");
            wrapper.find("input").attr("readonly", true);
        } else {
            $("#" + id).prop("readonly", true)
                       .addClass("k-state-disabled");
        }
    });
};

That extra wrapper logic ensures the control is truly locked visually and functionally ‚Äî even if some other code rebinds events.

‚úÖ Step 4 ‚Äî (Optional) Disable keyboard tabbing
If you want users to see values but not navigate into them:
$("#" + id).attr("tabindex", "-1");

You can add that line inside the same loop.

üîß TL;DR
ProblemFixControls not readonlyRun setPopupReadonly() after initVehiclePopupForm()Some widgets still editableAdd wrapper + input disable in setPopupReadonly()ReasoninitVehiclePopupForm re-enables or rebinds widgets

‚úÖ Final working pattern
loadVehicleForm(window.currentVehicleId, function () {
    setTimeout(function () {
        setPopupReadonly([...]);
        setPopupEditable(["NumOfVehicles"]);
    }, 200);
});


If you paste your initVehiclePopupForm() function (or show its core lines), I can pinpoint exactly which part is resetting the state ‚Äî and give you a cleaner hook instead of relying on a timeout.
Would you like me to do that?ASP.NET Telerik Guru said:Perfect ‚Äî now we can see everything working together:
‚úÖ openEstimatePopup() ‚Üí loads the partial, initializes widgets
‚úÖ initVehiclePopupForm() ‚Üí sets readonly/editable mode
‚úÖ wireVehicleForm() ‚Üí wires up save/cancel
‚úÖ loadVehicleForm() ‚Üí reloads Vehicle tab
And the problem you described:

‚ÄúWhen I click Vehicle tab (after switching from another tab), controls are not readonly.‚Äù

‚Ä¶makes total sense now, because initVehiclePopupForm() re-enables everything based on its mode logic.
Let‚Äôs unpack this cleanly üëá

üí° What‚Äôs really happening
When you come back to the Vehicle tab, your flow is:


loadVehicleForm(currentVehicleId) reloads the tab HTML.


Inside that .get() callback, you call wireVehicleForm().


openEstimatePopup() also calls initVehiclePopupForm() (with mode = ‚ÄúEdit‚Äù).


Now ‚Äî inside initVehiclePopupForm(), you have:
if (mode === "Add") {
    setPopupEditable([...]);
    setPopupReadonly([...]);
} else { // Edit
    setPopupReadonly([...]);
    setPopupEditable(["NumOfVehicles"]);
}

That looks good at first glance, but note ‚Äî when the tab reloads later, your partial probably contains this hidden field:
<input type="hidden" id="formMode" value="Edit" />

So every time the form loads, initVehiclePopupForm() runs again and toggles controls fresh.
But when you call it before widgets fully re-initialize (or call it multiple times), some controls end up half-initialized or re-enabled.

‚úÖ The clean and reliable pattern
We‚Äôll make three small changes to make this rock-solid:

üü¢ 1. Run initVehiclePopupForm() inside loadVehicleForm() after the form HTML loads
You want this to happen only after the partial content has been loaded and Kendo widgets exist.
Modify your loadVehicleForm():
window.loadVehicleForm = function (vehicleId, callback) {
    console.warn('window.loadVehicleForm :', vehicleId);

    $.get('@Url.Action("GetVehicleById", "Vehicles")', { id: vehicleId }, function (html) {
        $("#vehicleTabContent").html(html);
        window.tabContentLoaded[0] = true;

        // Initialize Kendo UI widgets in the new HTML
        kendo.init($("#vehicleTabContent"));

        // Rebind actions
        window.wireVehicleForm();

        // Apply readonly/edit mode logic AFTER widgets exist
        setTimeout(function () {
            window.initVehiclePopupForm();
        }, 100);

        // Enable/disable tabs depending on vehicleId
        var tabStrip = $("#estimateTabs").data("kendoTabStrip");
        if (vehicleId !== 0 && tabStrip) {
            for (var i = 1; i <= 7; i++) {
                tabStrip.enable(tabStrip.tabGroup.children().eq(i), true);
            }
        } else if (vehicleId === 0 && tabStrip) {
            for (var i = 1; i <= 7; i++) {
                tabStrip.enable(tabStrip.tabGroup.children().eq(i), false);
            }
        }

        if (typeof callback === "function") callback();
    });
};

Now you don‚Äôt need to manually call initVehiclePopupForm() after reload ‚Äî it runs as part of the load sequence every time.

üü¢ 2. Simplify your openEstimatePopup() (remove duplicate init logic)
You currently do this:
setTimeout(function () {
    setComboBoxValues();
    initVehiclePopupForm();
    wireVehicleForm();
}, 100);

Since loadVehicleForm() already handles wireVehicleForm() and initVehiclePopupForm(), remove those duplicate calls here.
Only keep setComboBoxValues().
setTimeout(function () {
    setComboBoxValues();
}, 100);

Otherwise, initVehiclePopupForm() runs twice ‚Äî once before, and once after widgets exist ‚Äî which causes exactly the mixed readonly/editable behavior you‚Äôre seeing.

üü¢ 3. Expand your getKendoWidget() helper to include all widget types
window.getKendoWidget = function (id) {
    var element = $("#" + id);
    return element.data("kendoComboBox") ||
           element.data("kendoDropDownList") ||
           element.data("kendoNumericTextBox") ||
           element.data("kendoDatePicker") ||
           element.data("kendoTextBox") ||
           element.data("kendoMaskedTextBox");
};

Some of your form fields (Year, Sopnumber, etc.) might be regular inputs or masked boxes ‚Äî this ensures they‚Äôre caught too.

üß© TL;DR
ProblemCauseFixControls not readonly when switching backinitVehiclePopupForm() re-runs too early / twiceMove it inside loadVehicleForm() callbackSome fields not detectedMissing widget typesExpand getKendoWidget()Multiple rebinds causing inconsistent UIinitVehiclePopupForm() called in multiple placesRemove extra call from openEstimatePopup()

‚úÖ End Result
