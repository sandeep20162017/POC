Here’s the updated version:

window.loadVehicleForm = function (vehicleId, callback) {
    console.warn('window.loadVehicleForm :', vehicleId);

    $.get('@Url.Action("GetVehicleById", "Vehicles")', { id: vehicleId }, function (html) {
        $("#vehicleTabContent").html(html);
        window.tabContentLoaded[0] = true;
        window.wireVehicleForm(); // rebind save/cancel/edit/etc

        var tabStrip = $("#estimateTabs").data("kendoTabStrip");

        // Enable/disable tabs based on record state
        if (vehicleId !== 0 && tabStrip) {
            for (var i = 1; i <= 7; i++) {
                tabStrip.enable(tabStrip.tabGroup.children().eq(i), true);
            }
        } else if (vehicleId === 0 && tabStrip) {
            for (var i = 1; i <= 7; i++) {
                tabStrip.enable(tabStrip.tabGroup.children().eq(i), false);
            }
        }

        // ✅ Run the callback after form is loaded
        if (typeof callback === "function") {
            callback();
        }
    });
};


Now you can pass in your read-only logic as a callback that runs after the DOM update completes.

✅ Step 2 — Expand your getKendoWidget helper

Your current helper doesn’t check for DropDownLists or TextBoxes, which are common in Telerik forms. Let’s make it more robust:

window.getKendoWidget = function (id) {
    var element = $("#" + id);
    return element.data("kendoComboBox") ||
           element.data("kendoDropDownList") ||
           element.data("kendoNumericTextBox") ||
           element.data("kendoDatePicker") ||
           element.data("kendoTextBox");
};

✅ Step 3 — Call setPopupReadonly() after loadVehicleForm

Inside your alert close handler, update this block:

loadVehicleForm(window.currentVehicleId, function () {
    setPopupReadonly([
        "VehicleListId", "VehSeriesCode", "ProjDesc", "Make", "VehModel", "Year",
        "Engine", "Transmission", "Differential", "Sopnumber",
        "ModifiedLastBy", "ModifiedLastDate"
    ]);

    setPopupEditable(["NumOfVehicles"]);
});


Now the setPopupReadonly and setPopupEditable functions execute after your Vehicle tab HTML and widgets are reloaded.

✅ Step 4 — Reuse the same logic when clicking the Vehicle tab manually

You mentioned the Vehicle tab is refreshed when clicked.
Add this inside your onTabSelect(e) handler for index 0:

if (index === 0) {
    loadVehicleForm(window.currentVehicleId, function () {
        setPopupReadonly([
            "VehicleListId", "VehSeriesCode", "ProjDesc", "Make", "VehModel", "Year",
            "Engine", "Transmission", "Differential", "Sopnumber",
            "ModifiedLastBy", "ModifiedLastDate"
        ]);
        setPopupEditable(["NumOfVehicles"]);
    });
    return;
}


Now every time the user comes back to the Vehicle tab, the form will reload from the database and immediately lock down the fields (except NumOfVehicles).

✅ Step 5 — Final working summary

Your final logic flow should look like this:

loadVehicleForm(vehicleId, callback) loads the HTML, rebinds events, and enables/disables tabs.

Inside that callback, you call your read-only logic.

You use the same call both:

After a save (in your alert close handler)

When the user re-selects the “Vehicle” tab

✅ Final pattern example

// after successful save or on Vehicle tab select
loadVehicleForm(window.currentVehicleId, function () {
    setPopupReadonly([
        "VehicleListId", "VehSeriesCode", "ProjDesc", "Make", "VehModel", "Year",
        "Engine", "Transmission", "Differential", "Sopnumber",
        "ModifiedLastBy", "ModifiedLastDate"
    ]);
    setPopupEditable(["NumOfVehicles"]);
});
