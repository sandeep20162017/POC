✅ Working Example
// Supplier Name ComboBox
@(Html.Kendo().ComboBox()
    .Name("OrigSupplierName")
    .DataTextField("Text")
    .DataValueField("Text")
    .Placeholder("Enter Supplier Name...")
    .AutoBind(false)
    .ClearButton(false)
    .HtmlAttributes(new { style = "width:100%" })
)

// Supplier Number ComboBox
@{
    var fieldName = ViewData.TemplateInfo.GetFullHtmlFieldName("");
}
@(Html.Kendo().ComboBox()
    .Name(fieldName)
    .DataTextField("Text")
    .DataValueField("Text")
    .Filter(FilterType.Contains)
    .Placeholder("Enter Supplier Number...")
    .AutoBind(false)
    .ClearButton(false)
    .Events(e => e.Change("onSupplierNumChange")) // 👈 event handler here
)

🧠 JavaScript handler
function onSupplierNumChange(e) {
    // Get Supplier Name combobox instance
    var supplierNameCombo = $("#OrigSupplierName").data("kendoComboBox");

    if (supplierNameCombo) {
        // Clear value and text safely
        supplierNameCombo.value("");
        supplierNameCombo.text("");
    }
}

🔍 Notes & Best Practices

Avoid recursion — clearing the SupplierName combo does not trigger your SupplierNum change event, so no recursion happens.

If these combos are inside a Kendo Grid (e.g., as editors in a column template), you should scope your selectors to the current row:

function onSupplierNumChange(e) {
    var row = $(e.sender.element).closest("tr");
    var supplierNameCombo = row.find("[data-role='combobox'][name='OrigSupplierName']").data("kendoComboBox");
    
    if (supplierNameCombo) {
        supplierNameCombo.value("");
        supplierNameCombo.text("");
    }
}


This ensures only the current row’s SupplierName combo gets cleared — not all of them in the grid.
